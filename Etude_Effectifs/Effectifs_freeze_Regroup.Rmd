---
title: "Effectif_freeze_Regroup"
author: "Manon Santrisse"
date: '2022-10-18'
output: pdf_document
---


```{r library, include=FALSE}
library(dplyr)
library(ggplot2)
library(corrplot)
library(readxl)
library(FactoMineR)
library(factoextra)
library(cowplot)
library("NbClust")
library(missForest)
library(writexl)
library("scales")
library(readr)
library(lubridate)
library(data.table)
```


# Récupération du jeu Effectifs_freeze.Rdata
```{r recup, echo=TRUE}
load('../Donnees/Effectifs_freeze.Rdata')
head(effectif)
```


# Définition du format pour chaque variable

- Gp assurés : mettre majorité
- Produit : Il y a plus de 2000 produits donc on ne peut pas faire une variable par produit. Une entreprise semble avoir au maximum 3 produits et chaque produit mène à une indexation différente donc il serait intéressant de garder les 3 produits les plus représenté par ordre et leur indexation
- Date d'adhésion : pas d'intérêt / mettre année la plus vieille
- Code APE : mettre majorité
- Département : mettre majorité
- Regroup 1 : mettre majorité
- Regroup 4 : semble 1 entreprise = 1 regroup 4
- Regroup 5 : Créer 4 catégories (Base, Option, Asso, Surcomp) et mettre la majorité
- Num pers/ num Ind: calculer nombre de personnes et de famille. Attention ! Enlever les personnes radiées
- Date adhésion pers : pas d'intérêt
- Date radiation : voir précédement
- Type assuré : 3 catégories = variables avec leurs effectifs
- Sexe : 2 catégories = variables avec leurs effectifs
- Date de naissance : pas d'intérêt / sinon tranche d'âge
- R/RN : 2 catégories = variables avec leurs effectifs
- Num contrat grandes entreprises: faire 1 variable oui/non
- Indexation 2018/2019/2020 : faire par produit ou si 1 produit faire une moyenne ou plusieurs catégorie avec des intervalles
- Renégo 2020/2021/2022 : variable oui/non


# Fonctions pour attribuer une ligne par entreprise

## Dataframes de test
```{r datatest, echo=FALSE}
df<-data.frame(c("a","a","b","b","b"))
colnames(df)<-"nom"
E1=subset(effectif,Num.Ctr.Coll.Anonyme==1)
E2=subset(effectif,Num.Ctr.Coll.Anonyme==2)
```


## Garder le max représenté
Pour les variables :
- Code groupe assurés
- Code APE
- Département
- Regroup1
- Regroup4


```{r fonct code ass}
max_repr <- function(data,ind) {
  frequences=as.data.frame(table(data[,ind]))
  ind_level_max=which(table(data[,ind])==max(table(data[,ind])))
  level_max=frequences[ind_level_max,1]
  return (as.character(level_max))
}
```

Test unitaire de max_repr
```{r test_unit_max_repr }
max_repr(df,1)
```

## Catégories et effectifs
Pour les varaibles suivantes :
- Type assuré
- Sexe
- R/RN
- Regroup5


```{r}
transpose(aggregate(E2$Type.Assure,list(E2$Type.Assure),length))
```


## Date d'adhésion entreprise
Pour la variable :
Date d'adhésion
```{r annee_adh_E}
annee_adh_E<-function(data){
  annee=year(data[,5])[1]
  return(annee)
}
```

Test unitaire
```{r}
annee_adh_E(E1)
```

## Temps d'adhésion entreprise

```{r temps_adhe_E}
temps_adh_E<-function(data){
  if(year(data[1,6])=='2050'){
    temps=as.numeric(Sys.Date()-data[1,5])
  }else{
    temps=as.numeric(data[1,6]-data[1,5])
  }
  return(as.integer(temps))
}
#retour en jours
```

```{r test_unit_tps_adh_E}
print(temps_adh_E(E1))
print(temps_adh_E(E2))
```

## Effectif personnes et familles
Pour les variables :
- Num pers
- Num ind

Avec retrait des personnes et familles radiées.
```{r fonct eff_pers_fam}
effectif_pers_fam<-function(data){
  data_sub=subset(data, year(data[,15])=='2050')
  nb_pers=nrow(data_sub)
  data_sub=droplevels(data_sub)
  nb_fam=length(levels(data_sub[,13]))
  return (c(nb_pers,nb_fam))
}
```

Test unitaire
```{r test_unit_pers_fam}
effectif_pers_fam(E1)
#nb pers, nb_fam
```


## Temps d'adhésion moyenne des personnes

```{r temps_adh_P}
temps_moy_adh_P<-function(data){
  adh=0
  #calcul temps adhesion de toutes les personnes
  for (i in 1:nrow(data)){
    if(year(data[i,15])=='2050'){
      adh=adh+as.numeric(Sys.Date()-data[i,14])
    }else{
      adh=adh+as.numeric(data[i,15]-data[i,14])
    }
    
  }
  #moyenne
  adh=adh/nrow(data)
  return (as.integer(adh))
}
#en jour
```


```{r test_unit_adh_moy}
temps_moy_adh_P(E2)
```
## Ancienneté moyenne

```{r ancienneté}
ancien<-function(data){
  anciennete=mean(year(data$Date.Effet.Adhesion.Num.Personne))
  return (as.integer(anciennete))
}
```

```{r}
print(ancien(E1))
print(ancien(E2))
```

## 0/1 pour Grands comptes

```{r boolean_gd_compte} 
# true or false
gd_compte<-function(data){
  return (data[1,21])
}
```


Test unitaire
```{r}
gd_compte(E2)
```

# Récupération du nombre d'entreprises et de liens
```{r}
effectif$Num.Ctr.Coll.Anonyme<-as.integer(effectif$Num.Ctr.Coll.Anonyme)
paste("Il y a ", max(effectif$Num.Ctr.Coll.Anonyme), "entreprises.")
effectif$Num.Ctr.Coll.Anonyme<-as.factor(effectif$Num.Ctr.Coll.Anonyme)
effectif$Lien.entreprise.Anonyme<-as.integer(effectif$Lien.entreprise.Anonyme)
paste("Il y a ",max(effectif$Lien.entreprise.Anonyme)," liens")
effectif$Lien.entreprise.Anonyme<-as.factor(effectif$Lien.entreprise.Anonyme)
```

## Création d'un dataframe pour récupérer ces nouvelles informations

```{r}
tab <- data.frame(Entreprise = integer(),
                 Lien_E = integer(),
                 Actifs = integer(),
                 Non_actifs = integer(),
                 Portabilite = integer(),
               #  Produit1= integer(),
               #  Produit2= integer(),
               #  Produit3= integer(),
                 Annee_adhesion = integer(),
                 Tps_adh_entreprise = integer(),
                 Max_code_ape = character(),
                 Max_departement= character(),
                 Max_regroup1= character(),
                 Max_regroup4=integer(),
                 BASE=numeric(), # en pourcentage
                 OPTION = numeric(), # en pourcentage
                 Nb_pers = integer(),
                 Nb_fam =integer(),
                 Anciennete_moy = integer(),
                 Tps_adh_moy_pers = integer(),
                 Asspri = integer(),# effectif ou pourcentage
                 Conjoint = integer(),
                 Enfant = integer(),
                 Femme = numeric(), # pourcentage
                 Homme = numeric(), #pourcentage
                 Respo = numeric(), # pourcentage
                 Non_respo = numeric(), #pourcentage
                 VIP = logical(),
                 Ind2018 = double(),
                 Ind2019 = double(),
                 Ind2020 = double(),
                 Ind2021 = double(),
                 Ind2022 = double(),
                 Ind2023 = double(),
                 Renégo2020 = logical(),
                 Renégo2021 = logical(),
                 Renégo2022= logical())

```                 
                 
                 
## Subdataset par num entreprise
Création d'une liste qui pour chaque indice regroupe les lignes correspondant à la i eme entreprise.

```{r}
sub_entreprises <- lapply(1:3843, function(x) subset(effectif,Num.Ctr.Coll.Anonyme==x)) 

```

