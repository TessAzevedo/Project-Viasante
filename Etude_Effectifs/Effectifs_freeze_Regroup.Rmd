---
title: "Effectif_freeze_Regroup"
author: "Manon Santrisse"
date: '2022-10-18'
output: pdf_document
---


```{r library, include=FALSE}
library(dplyr)
library(ggplot2)
library(corrplot)
library(readxl)
library(FactoMineR)
library(factoextra)
library(cowplot)
library("NbClust")
library(missForest)
library(writexl)
library("scales")
library(readr)
library(lubridate)
```


# Récupération du jeu Effectifs_freeze.Rdata
```{r recup, echo=TRUE}
eff=get(load('../Donnees/Effectifs_freeze.Rdata'))
head(eff)
```


# Définition du format pour chaque variable

- Gp assurés : mettre majorité
- Produit : Il y a plus de 2000 produits donc on ne peut pas faire une variable par produit. Une entreprise semble avoir au maximum 3 produits et chaque produit mène à une indexation différente donc il serait intéressant de garder les 3 produits les plus représenté par ordre et leur indexation
- Date d'adhésion : pas d'intérêt / mettre année la plus vieille
- Code APE : mettre majorité
- Département : mettre majorité
- Regroup 1 : mettre majorité
- Regroup 4 : semble 1 entreprise = 1 regroup 4
- Regroup 5 : Créer 4 catégories (Base, Option, Asso, Surcomp) et mettre la majorité
- Num pers/ num Ind: calculer nombre de personnes et de famille. Attention ! Enlever les personnes radiées
- Date adhésion pers : pas d'intérêt
- Date radiation : voir précédement
- Type assuré : 3 catégories = variables avec leurs effectifs
- Sexe : 2 catégories = variables avec leurs effectifs
- Date de naissance : pas d'intérêt / sinon tranche d'âge
- R/RN : 2 catégories = variables avec leurs effectifs
- Num contrat grandes entreprises: faire 1 variable oui/non
- Indexation 2018/2019/2020 : faire par produit ou si 1 produit faire une moyenne ou plusieurs catégorie avec des intervalles
- Renégo 2020/2021/2022 : variable oui/non


# Fonctions pour attribuer une ligne par entreprise

## Dataframes de test
```{r datatest, echo=FALSE}
df<-data.frame(c("a","a","b","b","b"))
colnames(df)<-"nom"
E1=subset(eff,Num.Ctr.Coll.Anonyme==1)
E2=subset(eff,Num.Ctr.Coll.Anonyme==2)
```


## Garder le max représenté
Pour les variables :
- Code groupe assurés
- Code APE
- Département
- Regroup1
- Regroup4


```{r fonct code ass}
max_repr <- function(data,ind) {
  frequences=as.data.frame(table(data[,ind]))
  ind_level_max=which(table(data[,ind])==max(table(data[,ind])))
  level_max=frequences[ind_level_max,1]
  return (as.character(level_max))
}
```

Test unitaire de max_repr
```{r test_unit_max_repr }
max_repr(df,1)
```

## Catégories et effectifs
Pour les varaibles suivantes :
- Type assuré
- Sexe
- R/RN
- Regroup5


```{r}
transpose (aggregate(E2$Type.Assure,list(E2$Type.Assure),length))
```


## Effectif personnes et familles
Pour les variables :
- Num pers
- Num ind

```{r fonct eff_pers_fam}
effectif_pers_fam<-function(data){
  data_sub=subset(data, year(data[,15])=='2050')
  nb_pers=nrow(data_sub)
  data_sub=droplevels(data_sub)
  nb_fam=length(levels(data_sub[,13]))
  return (c(nb_pers,nb_fam))
}
```

Test unitaire
```{r test_unit_pers_fam}
effectif_pers_fam(E1)
```

## Date d'adhésion entreprise
Pour la variable :
Date d'adhésion
```{r annee_adh_E}
annee_adh_E<-function(data){
  annee=year(data[,5])[1]
  return(annee)
}
```

Test unitaire
```{r}
annee_adh_E(E1)
```

## Temps d'adhésion entreprise

```{r temps_adhe_E}
temps_adh_E<-function(data){
  if(year(data[,6])=='2050'){
    temps=as.numeric(Sys.Date()-data[,5])
  }else{
    temps=as.numeric(data[,6]-data[,5])
  }
  return(as.integer(temps))
}
#retour en jours
```

## Temps d'adhésion

```{r temps_adh_P}
temps_moy_adh_P<-function(data){
  adh=0
  #calcul temps adhesion de toutes les personnes
  for (i in 1:nrow(data)){
    if(year(data[i,15])=='2050'){
      adh=adh+as.numeric(Sys.Date()-data[i,14])
    }else{
      adh=adh+as.numeric(data[i,15]-data[i,14])
    }
    
  }
  #moyenne
  adh=adh/nrow(data)
  return (as.integer(adh))
}
```


```{r test_unit_adh_moy}
temps_moy_adh_P(E2)
```
## Ancienneté moyenne

```{r ancienneté}
ancien<-function(data){
  anciennete=mean(year(data$Date.Effet.Adhesion.Num.Personne))
  return (as.integer(anciennete))
}
```

## 0/1 pour Grands comptes

```{r boolean_gd_compte}
gd_compte<-function(data){
  return(data[1,21])
}
```


Test unitaire
```{r}
gd_compte(E2)
```

# Récupération du nombre exacte d'entreprises
```{r}
print(max(Num_E))

```


## Création d'un dataframe pour récupérer ces nouvelles informations

```{r}
tab <- data.frame(Entreprise = integer(),
                 Lien_E = integer(),
                 Gp_ass = character(),
                 Cd_vente = character(),
                 Produit1= integer(),
                 Porduit2= integer(),
                 Produit3= integer(),
                 Code_APE= character(),
                 Département= character(),
                 Regroup1= character(),
                 Regroup4=character(),
                 Regroup5=character(),
                 Nb_adhérent = integer(),
                 Nb_fam =integer(),
                 Type_assures = character(),
                 Sexe = character(),
                 R_RN =character(),
                 VIP = logical(),
                 Ind2018 = double(),
                 Ind2019 = double(),
                 Ind2020 = double(),
                 Renégo2020 = logical(),
                 Renégo2021 = logical(),
                 Renégo2022= logical())

```                 
                 
                 
## Subdataset par num entreprise
Création d'une liste qui pour chaque indice regroupe les lignes correspondant à la i eme entreprise.

```{r}
sub_entreprises <- lapply(1:3843, function(x) subset(data,Num_E==x)) 

```


























